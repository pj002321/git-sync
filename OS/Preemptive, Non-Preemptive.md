# Preemptive, Non-Preemptive
----
CPU를 어떤 프로세스에게 할당하고 언제 회수할지 결정하는 스케줄링 방식이다.

>[!Non-Preemptive (비선점형)]
>한 번 CPU를 할당받은 프로세스가 스스로 CPU를 반납하거나 작업이 완료될 때까지 CPU를 빼앗기지 않는 방식.
>실행 중인 프로세스가 입출력 등으로 대기 상태로 전환될 때까지 다른 프로세스는 CPU를 사용할 수 없다.
>구현이 비교적 간단하고 문맥 전환 오버헤드가 적지만, 짧은 작업이 긴 작업 뒤에 있다면 무한정 기다리는 Conboy효과 나 응답 시간 저하가 발생할 수 있다.

>[!Preemptive (선점형)]
>운영체제가 실행 중인 프로세스로 부터 강제로 CPU를 회수하여 다른 프로세스에게 할당할 수 있는 방식.
>보통 우선순위가 높은 프로세스가 나타나거나, 할당된 시간이 만료되면 발생.
>짧은 작업에게 빠르게 CPU를 할당하여 응답성을 높이고, CPU 독점을 방지하여 공정성을 개성.
>문맥 전환은 비선점형보다 크다.
>현대 대부분의 운영체제는 선점형 스케줄링을 사용.

**📄 각 스케줄링 방식의 장단점**
Non-Preemptive는 구현이 간단하고 문맥 전환 오버헤드가 적지만, 응답성이 낮아지고 특정 프로세스가 CPU를 오래 점유하면 다른 프로세스들이 기다려야 하는 단점이 있습니다. Preemptive는 응답성과 공정성이 뛰어나 여러 작업을 동시에 수행하는 환경에 적합하지만, 문맥 전환 오버헤드가 크고 구현이 더 복잡합니다.

**📄 First-Come, First-Served(FCFS)와 Round Robin(RR) 스케줄링 알고리즘은 각각 어떤 방식에 해당하나요? 이유는요?
FCFS는 Non-Preemptive 방식입니다. 한 번 CPU를 얻은 프로세스는 작업이 끝날 때까지 실행되기 때문입니다. Round Robin은 Preemptive 방식입니다. 각 프로세스에게 정해진 시간 할당량(Time Slice)만 부여하고 시간이 지나면 강제로 CPU를 빼앗아 다른 프로세스에게 넘겨주기 때문입니다.

**📄 왜 현대 운영체제에서는 주로 Preemptive 스케줄링을 사용하나요?**
현대 운영체제는 다중 사용자 및 대화형 환경을 지원합니다. Preemptive 스케줄링은 각 프로세스에게 공정하게 CPU 시간을 분배하고, 사용자의 입력에 빠르게 응답할 수 있도록 프로세스의 응답성을 높이는 데 유리하기 때문에 주로 사용됩니다.

**📄 Non-Preemptive 스케줄링 시 발생할 수 있는 'Convoy 효과'는 무엇인가요?**
CPU 사용 시간이 긴 프로세스가 먼저 도착하여 CPU를 점유하고 있는 동안, 뒤에 도착한 CPU 사용 시간이 짧은 여러 프로세스들이 그 긴 프로세스가 끝날 때까지 기다려야 하는 현상입니다. 이는 짧은 프로세스들의 평균 대기 시간을 크게 늘립니다.


[[OS]]