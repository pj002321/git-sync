```cpp
int main()
{
	int N, a[10] = {}, ans = 0;
	cin >> N;

	while (N)
	{
		a[N % 10]++;
		N /= 10;

	}

	for (int i = 0; i < 10; i++) {
		if (i == 6 || i == 9) continue;
		ans = max(ans,a[i]); 
	}
	ans = max(ans,(a[6]+a[9]+1)/2); 
	cout << ans;
}

/*
* a[6] + a[9]: 6과 9의 총 필요 개수
+1: 올림 효과 (정수 나눗셈에서 올림을 위해)
/2: 한 세트당 6과 9를 각각 하나씩 사용할 수 있으므로
*/
```

**예시: N = 1475라고 가정**

1. **첫 번째 반복**:
    - `N % 10 = 1475 % 10 = 5` → `a[5]++` (5의 개수 증가)
    - `N /= 10` → `N = 1475 / 10 = 147`
2. **두 번째 반복**:
    - `N % 10 = 147 % 10 = 7` → `a[7]++` (7의 개수 증가)
    - `N /= 10` → `N = 147 / 10 = 14`
3. **세 번째 반복**:
    - `N % 10 = 14 % 10 = 4` → `a[4]++` (4의 개수 증가)
    - `N /= 10` → `N = 14 / 10 = 1`
4. **네 번째 반복**:
    - `N % 10 = 1 % 10 = 1` → `a[1]++` (1의 개수



**원리**
예를 들어:

- **122269**라는 숫자가 있으면
- 1이 1개, 2가 3개, 6이 1개, 9가 1개 필요
- 한 세트에는 각 숫자가 하나씩만 들어있으니까
- 2를 3개 쓰려면 세트를 3개 사야 함
- 따라서 **3세트**가 필요

**3436**이라면:

- 3이 2개, 4가 1개, 6이 1개 필요
- 3을 2개 쓰려면 세트를 2개 사야 함
- 따라서 **2세트**가 필요

핵심은:

- 각 숫자별로 필요한 개수를 센다
- 그 중에서 **가장 많이 필요한 숫자의 개수 = 필요한 세트 수**
- 단, 6과 9는 서로 뒤집어 쓸 수 있어서 특별 처리