https://www.acmicpc.net/problem/3273

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

int main()
{
	int n, x;
	
	int a[100001] = {};
	bool occur[200001] = {};

	int ans = 0;
	cin >> n;
	for (int i = 0; i < n; i++) cin >> a[i];
	cin >> x;

	for (int i = 0; i < n; i++) {
		if (x - a[i] > 0 && occur[x - a[i]]) ans++;
		occur[a[i]] = true;
	}
	cout << ans;
}
```
## 수학적 변환

- **목표**: `a[i] + a[j] = x` 인 쌍 찾기
- **변형**: `a[j] = x - a[i]`

## 알고리즘 논리

현재 숫자 `a[i]`를 볼 때:

1. **"이 숫자와 짝을 이룰 수 있는 숫자는 `x - a[i]`야"**
2. **"그런 숫자가 이전에 나왔었나?"** → `occur[x - a[i]]` 확인
3. **나왔다면 쌍 발견!** → `ans++`

## 예시로 이해하기

`x = 7`, 배열 `[2, 3, 5, 1]`

- **i=0, a[0]=2**: `7-2=5` 찾기 → occur[5] = false → 쌍 없음
- **i=1, a[1]=3**: `7-3=4` 찾기 → occur[4] = false → 쌍 없음
- **i=2, a[2]=5**: `7-5=2` 찾기 → occur[2] = **true** → 쌍 발견! (2,5)
- **i=3, a[3]=1**: `7-1=6` 찾기 → occur[6] = false → 쌍 없음


**투 포인터 방식**

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;
int main()
{
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
    {
        cin >> a[i];
    }
    int x;
    cin >> x;
    sort(a.begin(), a.end());
    int left = 0, right = n - 1;
    int count = 0;
    while (left < right)
    {
        if (a[left] + a[right] == x)
        {
            count++;
            left++;
            right--;
        }
        else if (a[left] + a[right] < x)
        {
            left++;
        }
        else
        {
            right--;
        }
    }
    cout << count << endl;
    return 0;
}

```