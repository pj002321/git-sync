실제 객체에 직접 접근하지 않고, 대리 객체(Proxy)를 통해 접근을 제어하는 구조 패턴.

왜 쓰는지?
- 실제 객체의 생성,접근,비용,권한,로딩 시점을 제어하기 위해 사용.

언제 쓰는지?
- 무거운 리소스 지연 로딩, 네트워크 객체 접근, 권한 체크, 로깅 및 검증 필요한 시스템에 사용.

장점 
- 접근 제어, 지연 로딩, 부가 기능 추가 가능하며 기존 객체 수정 없이 기능을 확장할 수 있다.

단점
- 클래스 수 증가로 구조가 복잡해질 수 있으며 디버깅 난이도 올라감.

구조
- 공통 인터페이스를 구현한 RealSubject와 Proxy가 존재하고, Client는 Proxy를 통해 RealSubject에 접근한다. 
```csharp
public interface ICharacter
{
    void Attack();
}
public class RealCharacter : ICharacter
{
    public void Attack()
    {
        Console.WriteLine("캐릭터가 공격한다");
    }
}
public class CharacterProxy : ICharacter
{
    private RealCharacter realCharacter;

    public void Attack()
    {
        // 접근 제어 / 지연 로딩 / 검증 가능
        if (realCharacter == null)
        {
            realCharacter = new RealCharacter(); // 지연 생성
        }

        Console.WriteLine("공격 가능 여부 체크");
        realCharacter.Attack();
    }
}


```

[[DesignPattern]]