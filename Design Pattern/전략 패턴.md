동일한 목적의 알고리즘들을 캡슐화하고, 런타임에 교체 가능하도록 만드는 행동 패턴.

왜 쓰는지?
- 조건문(if/switch)으로 분기되는 로직을 제거하고, 행동(알고리즘)을 객체로 분리해 유연하게 교체하기 위해 사용한다.

언제 쓰는지?
- 공격 방식(근접/원거리/마법)
- AI 행동 패턴
- 이동 로직(걷기, 날기, 텔포)
- 데미지 계산 방식(물리, 마법, 크리티컬)

장점
- 조건문 감소로 가독성과 유지보수성 향상
- 런타임 중 전략 교체 가능
- 새로운 전략 추가 시 기존 코드 수정 최소화

단점
- 구조 이해 못하면 산으로감.

구조
Client → Context → Strategy Interface → ConcreteStrategy

```csharp
public interface IAttackStrategy
{
    void Attack();
}
public class MeleeAttack : IAttackStrategy
{
    public void Attack()
    {
        Console.WriteLine("근접 공격");
    }
}

public class RangedAttack : IAttackStrategy
{
    public void Attack()
    {
        Console.WriteLine("원거리 공격");
    }
}
public class Player
{
    private IAttackStrategy attackStrategy;

    public void SetStrategy(IAttackStrategy strategy)
    {
        attackStrategy = strategy;
    }

    public void Attack()
    {
        attackStrategy.Attack();
    }
}

// Use
Player player = new Player();

player.SetStrategy(new MeleeAttack());
player.Attack();

player.SetStrategy(new RangedAttack());
player.Attack();



```
[[DesignPattern]]