[[Algorithm]]
```c++
int number =10;
int data[number] = {1,10,3,4,5,6,7,3,4};

void quickSort(int* data, int start, int end) {
	if(start>=end) { // 원소가 1개인 경우
		return;
	}
	int key = start; // 키는 첫번 째 원소
	int i=start+1;
	int j = end;
	int temp;
	while(i<=j) { // 엇갈릴 때까지 반복
	/*오름차순 (<=/>=) | 내림 차순 (>=/<=) */
		while(data[i] <= data[key]) { // 키 값보다 클 때
			i++;
		}
		while(data[j] >= data[key] && j>start) { // 키 값보다 작을 때
			j--;
		}
		if(i>j) {
			temp = data[key];
			data[j]= data[key];
			data[key] = temp;
		}
		else{
			temp = data[j];
			data[j] = data[i];
			data[i] = temp;
		}
		quickSort(data,start,j-1);
		quickSort(data,j+1,end);
	}
}
int main(void){
	quickSort(data,0,number-1);
	
}
```

* 기존의 정렬 알고리즘들은 개수가 10만 개만 넘어가도 일반적인 상황에서 사용하기가 매우 어렵다. 
* 특정한 값을 **기준**으로 큰 숫자와 작은 숫자를 나누면 어떨까
* 3 7 8 1 5 9 6 10 2 4 -> 3을 기준으로 왼->오 (큰 값 찾기) | 오 -> 왼 (작은 값 찾기)
* 3 2 8 1 5 9 6 10 7 4

**시간복잡도**

  퀵 정렬은 대표적으로 분할 정복 알고리즘으로 평균 속도가  O(N * logN) 이다.
  [ log2N 이고 N이 100,000,0 일 떄, log2N은 20이다. ]

<선택>
* 1 2 3 4 5 6 7 8 9 10 => N^2 => 10 * 10 = 100
<퀵>
* 12345 => N^2 => 25
* 678910  => 25


평균 : O(N * logN)
최악 : O(N * N) 
-> 이미 정렬이 되어있는 경우. 는 삽입정렬이 더 빠르다.


