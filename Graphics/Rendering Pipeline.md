
# Rendering Pipeline

렌더링 파이프라인은 3D 모델 데이터를 받아 최종적으로 화면에 픽셀을 그리기까지의 일련의 단계들로 구성됩니다. 각 단계는 특정 작업을 수행하며, 일부 단계는 프로그래밍 가능한 셰이더를 사용하고, 다른 단계는 GPU의 고정 기능 하드웨어로 처리됩니다.

---
![[Pasted image 20250602102518.png]]
### 1. 입력 어셈블러 (Input-Assembler Stage, IA)
* 메모리(버텍스 버퍼, 인덱스 버퍼)로부터 정점 데이터를 읽어와 기본 기하 도형(프리미티브 - 점, 선, 삼각형 등)을 조립합니다.
* 이 프리미티브들은 다음 단계로 전달됩니다.

---

### 2. 정점 셰이더 (Vertex Shader Stage, VS)
* **프로그래밍 가능 (필수).**
* 각 정점(vertex)에 대해 실행됩니다.
* 주요 작업:
    * **좌표 변환**: 모델 좌표계 -> 월드 좌표계 -> 뷰 좌표계 -> 투영 좌표계 (클립 공간).
    * 텍스처 좌표 변환, 정점 색상 계산 등.
* 변환된 정점 데이터를 다음 단계로 전달합니다.

---

### 3. 헐 셰이더 (Hull Shader Stage, HS)
* **프로그래밍 가능 (선택적, 테셀레이션과 함께 사용).**
* 테셀레이션(Tessellation)을 위한 준비 단계입니다.
* 입력 패치(patch, 여러 정점으로 구성된 표면 조각)를 받아 얼마나 세밀하게 나눌지(테셀레이션 계수)와 패치 상수 데이터를 계산합니다.

---

### 4. 테셀레이터 (Tessellator Stage)
* **고정 기능 (선택적, HS/DS와 함께 사용).**
* 헐 셰이더에서 결정된 테셀레이션 계수를 바탕으로 패치를 더 작은 삼각형(또는 선, 점)으로 실제 분할합니다.
* 생성된 작은 프리미티브들은 도메인 셰이더로 전달됩니다.

---

### 5. 도메인 셰이더 (Domain Shader Stage, DS)
* **프로그래밍 가능 (선택적, 테셀레이션과 함께 사용).**
* 테셀레이터에 의해 생성된 각 새 정점에 대해 실행됩니다.
* 분할된 정점의 최종 위치를 계산합니다. (예: 높이 맵을 이용한 지형 디테일 표현)

---

### 6. 기하 셰이더 (Geometry Shader Stage, GS)
* **프로그래밍 가능 (선택적).**
* 하나의 완전한 프리미티브(점, 선, 삼각형) 또는 인접 정보를 포함한 프리미티브를 입력으로 받습니다.
* 프리미티브를 변형, 생성 또는 제거할 수 있습니다. (예: 파티클 생성, 법선 벡터 시각화, 프리미티브 확장)
* 결과 프리미티브를 스트림 출력 단계 또는 래스터라이저 단계로 보낼 수 있습니다.

---

### 7. 스트림 출력 (Stream-Output Stage, SO)
* **고정 기능 (선택적).**
* 기하 셰이더(또는 이전 단계의 정점 셰이더)에서 처리된 정점 데이터를 메모리 버퍼로 다시 쓸 수 있게 합니다.
* 렌더링 없이 GPU에서 생성된 데이터를 다시 CPU에서 사용하거나 다른 GPU 작업에 활용할 때 유용합니다. (예: 파티클 시뮬레이션의 결과 저장)

---

### 8. 래스터라이저 (Rasterizer Stage, RS)
* **고정 기능 (일부 설정 가능).**
* 벡터 그래픽(기하 도형)을 래스터 그래픽(픽셀)으로 변환합니다.
* 클립 공간의 프리미티브들을 화면 공간으로 변환하고, 해당 프리미티브가 어떤 픽셀들을 덮는지 결정합니다.
* 이 과정에서 **클리핑(Clipping)**, **원근 나누기(Perspective Division)**, **뷰포트 변환(Viewport Transform)**, **이면 컬링(Back-face Culling)**, **스캔 변환(Scan Conversion)** 등이 수행됩니다.
* 결과적으로 픽셀 셰이더에서 처리할 픽셀 후보(프래그먼트)를 생성합니다.

---

### 9. 픽셀 셰이더 (Pixel Shader Stage, PS)
* **프로그래밍 가능 (필수).**
* 래스터라이저에 의해 생성된 각 프래그먼트(픽셀)에 대해 실행됩니다.
* 주요 작업:
    * 텍스처 샘플링, 조명 계산, 색상 보간 등을 통해 픽셀의 최종 색상을 결정합니다.
    * 깊이 값도 출력할 수 있습니다.
* 출력된 색상과 깊이 값은 다음 단계인 출력 병합기로 전달됩니다.

---

### 10. 출력 병합기 (Output-Merger Stage, OM)
* **고정 기능 (일부 설정 가능).**
* 픽셀 셰이더에서 나온 최종 색상 값을 프레임 버퍼(렌더 타겟)에 씁니다.
* **깊이 테스트(Depth Test)**와 **스텐실 테스트(Stencil Test)**를 수행하여 픽셀이 그려질지 여부를 결정합니다.
* **블렌딩(Blending)**을 통해 반투명 효과 등을 구현합니다. (새로운 픽셀 색상과 기존 프레임 버퍼의 색상을 혼합)

---

이러한 단계들을 거쳐 3D 씬의 데이터가 최종적으로 2D 이미지로 렌더링되어 화면에 표시됩니다. 각 단계는 GPU 내에서 효율적으로 처리되도록 설계되어 있습니다.

---

# DirectX 11 vs DirectX 12 비교 🚀

DirectX는 Microsoft Windows 플랫폼에서 멀티미디어, 특히 게임 프로그래밍과 비디오 관련 작업을 위한 API(Application Programming Interface) 모음입니다. 이 중 Direct3D는 3D 그래픽스 렌더링을 담당하며, 버전 11과 12는 중요한 차이점을 가지고 있습니다.

---

## 주요 차이점 요약

| 특징                 | DirectX 11 (DX11)                               | DirectX 12 (DX12)                                         |
| -------------------- | ------------------------------------------------- | --------------------------------------------------------- |
| **API 수준** | 하이 레벨 (High-Level) API                         | 로우 레벨 (Low-Level) API                                  |
| **CPU 오버헤드** | 상대적으로 높음                                     | 크게 감소                                                   |
| **멀티스레딩** | 제한적 지원, 주로 단일 코어에 드로우 콜 집중             | 멀티 코어 CPU를 효율적으로 활용, 병렬 처리 강화                  |
| **하드웨어 제어** | 드라이버와 API가 많은 부분 자동 관리                    | 개발자에게 더 많은 직접적인 하드웨어 제어 권한 제공              |
| **파이프라인 상태 관리** | 상태 객체(State Objects) 분리, 런타임에 동적 변경      | 파이프라인 상태 객체(PSO)로 묶어 미리 컴파일, 효율적 전환        |
| **리소스 바인딩** | 상대적으로 단순                                     | 더 유연하고 복잡한 디스크립터 테이블 및 힙 기반                |
| **개발 복잡도** | 상대적으로 쉬움                                     | 더 복잡하고 많은 관리 필요 (메모리, 동기화 등)                |
| **주요 목표** | 사용 편의성과 안정성                                | 하드웨어 성능 극한 활용 및 CPU 병목 현상 감소                   |
| **지원 OS** | Windows Vista SP2 이상                             | Windows 10 이상                                            |

---

## 세부 비교

### 🧠 CPU 활용 및 오버헤드

* **DX11:**
    * 주로 단일 CPU 코어에서 드로우 콜(Draw Call)을 처리하려는 경향이 있어, 복잡한 씬에서는 CPU가 병목 현상의 원인이 될 수 있습니다.
    * 드라이버가 많은 작업을 백그라운드에서 처리하므로 CPU 오버헤드가 발생합니다.
* **DX12:**
    * **로우 레벨 API**로 설계되어 CPU 오버헤드를 크게 줄였습니다.
    * **커맨드 리스트(Command Lists)**와 **번들(Bundles)**을 통해 여러 CPU 코어에서 병렬로 렌더링 명령을 준비하고 GPU에 제출할 수 있습니다.
    * 이를 통해 다중 코어 CPU의 활용률을 극대화하고, CPU 병목 현상을 완화하여 GPU가 더 많은 시간 동안 효율적으로 작업할 수 있도록 합니다.

---

### 🛠️ 하드웨어 제어 및 API 디자인

* **DX11:**
    * **하이 레벨 API**로, 드라이버가 메모리 관리, 동기화, 상태 전환 등 많은 부분을 추상화하고 자동으로 처리합니다. 개발자는 상대적으로 쉽게 그래픽스 기능을 구현할 수 있습니다.
    * 리소스 상태 관리가 드라이버에 의해 암시적으로 이루어지는 경우가 많습니다.
* **DX12:**
    * 개발자에게 GPU 하드웨어에 대한 더 **직접적이고 세밀한 제어 권한**을 부여합니다.
    * **파이프라인 상태 객체(Pipeline State Objects, PSOs)**: 셰이더, 래스터라이저 상태, 블렌드 상태 등 대부분의 파이프라인 상태를 하나의 객체로 묶어 미리 컴파일합니다. 이를 통해 런타임 시 파이프라인 상태 변경 비용을 크게 줄여줍니다. DX11에서는 이러한 상태들이 개별적으로 설정되어 동적 변경 시 오버헤드가 있었습니다.
    * **리소스 장벽(Resource Barriers)**: 개발자가 명시적으로 리소스의 상태(예: 렌더 타겟에서 셰이더 리소스로)를 전환해야 합니다. 이는 더 많은 제어를 제공하지만, 개발자의 책임도 커집니다.
    * **디스크립터 힙(Descriptor Heaps) 및 테이블(Descriptor Tables)**: 리소스 바인딩 모델이 변경되어, 셰이더가 리소스에 접근하는 방식이 더 유연해지고 효율적으로 관리될 수 있도록 합니다.

---

### ✨ 새로운 기능 및 개선 사항 (DX12 중심)

* **비동기 컴퓨트 (Asynchronous Compute):**
    * 그래픽 작업과 컴퓨트 작업을 GPU에서 병렬로 실행할 수 있게 하여 GPU 활용률을 높입니다. DX11에서는 제한적이거나 드라이버 구현에 의존적이었습니다.
* **명시적 멀티 어댑터 (Explicit Multi-Adapter):**
    * 여러 GPU(다른 제조사 GPU 포함)를 동시에 활용하여 성능을 향상시킬 수 있는 기능을 제공합니다. 개발자가 각 GPU의 작업을 직접 제어해야 합니다.
* **DirectX Raytracing (DXR):**
    * 실시간 레이 트레이싱을 위한 표준 API를 제공하여, 더 사실적인 그림자, 반사, 전역 조명 효과를 구현할 수 있습니다. (DX11에서는 지원하지 않음)
* **가변 비율 셰이딩 (Variable Rate Shading, VRS):**
    * 이미지의 특정 부분에 대해 셰이딩 비율을 동적으로 조절하여, 시각적 품질 손실을 최소화하면서 성능을 향상시킬 수 있습니다.
* **메시 셰이더 (Mesh Shaders):**
    * 기존의 정점/기하 셰이더 파이프라인을 대체하거나 보강할 수 있는 새로운 지오메트리 처리 방식을 제공하여, 더 유연하고 효율적인 객체 컬링 및 렌더링이 가능합니다.
* **샘플러 피드백 (Sampler Feedback):**
    * 텍스처 샘플링 정보를 기록하여, 텍스처 스트리밍이나 텍스처 공간 셰이딩과 같은 고급 기술을 효율적으로 구현할 수 있도록 돕습니다.

---

## 개발자 관점 💻

* **DX11:**
    * 배우고 사용하기 비교적 쉽습니다.
    * 드라이버 최적화에 많이 의존하며, 안정적인 성능을 제공하는 경우가 많습니다.
    * 여전히 많은 게임과 애플리케이션에서 널리 사용됩니다.
* **DX12:**
    * 더 높은 수준의 전문성과 노력이 필요합니다. (메모리 관리, 동기화, 리소스 상태 관리 등)
    * 최적화가 잘 이루어지면 DX11보다 훨씬 뛰어난 성능을 보여줄 수 있지만, 그렇지 않으면 오히려 성능이 낮거나 불안정할 수 있습니다.
    * 최신 하드웨어의 기능을 최대한 활용하고자 할 때 강력한 선택지입니다.

---

## 결론 🎯

**DirectX 12**는 **DirectX 11**에 비해 하드웨어에 더 가깝게 접근하여 **CPU 오버헤드를 줄이고 멀티 코어 프로세서를 더 잘 활용**하도록 설계되었습니다. 이를 통해 특히 CPU 바운드 상황에서 상당한 성능 향상을 가져올 수 있습니다. 또한, DXR, VRS, 메시 셰이더와 같은 최신 그래픽 기술을 지원하여 시각적 품질과 렌더링 효율성을 한층 높일 수 있습니다.

하지만 이러한 유연성과 성능은 **개발 복잡도 증가**를 수반합니다. 개발자는 메모리 관리, 동기화, 리소스 상태 전환 등을 더 명시적으로 처리해야 합니다. 따라서 프로젝트의 목표, 팀의 숙련도, 대상 하드웨어 등을 고려하여 적절한 API를 선택하는 것이 중요합니다. 최신 게임들은 점차 DX12의 이점을 활용하는 추세에 있습니다.

[[Graphics]]