# 그래픽스 변환 파이프라인과 행렬

3D 모델의 정점(Vertex) 데이터가 화면에 그려지기까지 여러 단계의 좌표계 변환을 거치게 되며, 각 단계마다 행렬이 사용됩니다. 이 과정을 **그래픽스 변환 파이프라인**이라고 합니다.

1.  **로컬 공간 (Local Space / Object Space) -> 월드 공간 (World Space)**
    * **개념:** 각 3D 모델은 자신만의 원점(Pivot)과 좌표계를 가집니다. 이를 **로컬 공간**이라고 합니다.
    * **변환 (모델 변환 / 월드 변환):** 로컬 공간에 정의된 모델의 정점들을 게임 세계 전체의 공통된 원점을 기준으로 하는 **월드 공간**으로 옮기는 과정입니다.
    * **행렬:** **월드 행렬 (World Matrix)** 또는 **모델 행렬 (Model Matrix)**이 사용됩니다. 이 행렬은 일반적으로 모델의 크기 조절(Scale), 회전(Rotation), 이동(Translation) 변환 행렬들의 곱으로 구성됩니다 ($M_{world} = T \cdot R \cdot S$).
    * **계산:** `월드 좌표 = 월드 행렬 * 로컬 좌표`

2.  **월드 공간 (World Space) -> 뷰 공간 (View Space / Camera Space)**
    * **개념:** 월드 공간에 배치된 물체들을 관찰하는 카메라의 시점으로 좌표계를 변경합니다. 이를 **뷰 공간** 또는 **카메라 공간**이라고 합니다.
    * **변환 (뷰 변환):** 카메라의 위치와 방향에 따라 월드 전체를 변환하여, 마치 카메라가 월드 공간의 원점에 있고 특정 축을 바라보는 것처럼 만듭니다.
    * **행렬:** **뷰 행렬 (View Matrix)**이 사용됩니다. 이 행렬은 카메라의 위치(eye), 바라보는 지점(target/at), 그리고 카메라의 위쪽 방향(up vector)을 이용해 생성됩니다.
    * **계산:** `뷰 좌표 = 뷰 행렬 * 월드 좌표`

3.  **뷰 공간 (View Space) -> 클립 공간 (Clip Space / Homogeneous Clip Space)**
    * **개념:** 3차원 뷰 공간의 장면을 2차원 화면에 보여주기 위한 준비 단계입니다. 카메라의 시야 범위(절두체, Frustum) 밖에 있는 부분은 잘라내기(clipping) 위한 좌표계입니다.
    * **변환 (투영 변환):** 3D 장면을 2D로 "납작하게" 만드는 과정을 정의합니다. 원근감을 주거나(원근 투영), 물체의 깊이와 상관없이 크기를 유지하도록(직교 투영) 합니다.
    * **행렬:** **투영 행렬 (Projection Matrix)**이 사용됩니다.
        * **원근 투영 (Perspective Projection):** 시야각(Field of View, FOV), 종횡비(Aspect Ratio), 근평면(Near Clipping Plane), 원평면(Far Clipping Plane)을 파라미터로 사용합니다.
        * **직교 투영 (Orthographic Projection):** 절두체의 폭, 높이, 깊이 범위를 정의합니다.
    * **계산:** `클립 좌표 = 투영 행렬 * 뷰 좌표`
        * 이 결과로 나온 클립 좌표는 동차 좌표(x, y, z, w) 형태를 가집니다. `w` 값은 원근 투영 시 깊이 정보를 담고 있으며, 이후 원근 나누기에 사용됩니다.

4.  **클립 공간 (Clip Space) -> 정규화된 장치 좌표 (Normalized Device Coordinates, NDC)**
    * **개념:** 클립 좌표를 `w` 성분으로 나누어 정규화된 범위 (보통 x, y, z 각각 -1에서 1 사이, 또는 DirectX의 경우 z는 0에서 1 사이)로 만듭니다. 이 공간은 하드웨어가 실제로 래스터화(Rasterization)를 수행하기 용이한 표준화된 3D 공간입니다.
    * **변환 (원근 나누기, Perspective Division):**
    * **계산:**
        `NDC.x = 클립 좌표.x / 클립 좌표.w`
        `NDC.y = 클립 좌표.y / 클립 좌표.w`
        `NDC.z = 클립 좌표.z / 클립 좌표.w`
    * 이 단계 이후, 절두체 밖에 있는 폴리곤들은 실제로 잘려나가거나(Clipping), 일부만 남겨집니다.

5.  **정규화된 장치 좌표 (NDC) -> 화면 공간 (Screen Space)**
    * **개념:** NDC 공간의 좌표를 실제 모니터나 윈도우의 픽셀 좌표인 **화면 공간**으로 변환합니다.
    * **변환 (뷰포트 변환, Viewport Transformation):** NDC의 [-1, 1] (또는 [0, 1]) 범위를 화면의 특정 영역(뷰포트)의 픽셀 좌표 (예: (0,0)부터 (너비-1, 높이-1))로 매핑합니다. z값은 보통 깊이 버퍼(Depth Buffer)에 사용됩니다.
    * **행렬:** (내부적으로) **뷰포트 행렬 (Viewport Matrix)**이 사용될 수 있지만, 보통은 간단한 스케일링과 이동 연산으로 직접 계산됩니다.
    * **계산:** `화면 좌표 = 뷰포트 변환 연산(NDC 좌표)`

---

**요약:**

정점의 최종 화면 위치는 다음과 같은 일련의 행렬 곱으로 계산됩니다 (원근 나누기 및 뷰포트 변환은 약간 다른 형태로 적용됨):

`최종 좌표 ≈ 뷰포트 변환 * (원근 나누기) * 투영 행렬 * 뷰 행렬 * 월드 행렬 * 로컬 좌표`

특히, 셰이더 프로그래밍에서는 성능을 위해 **모델-뷰-투영 행렬 (MVP Matrix)**을 미리 계산하여 사용하는 경우가 많습니다:

$MVP = M_{projection} \cdot M_{view} \cdot M_{world}$
$P_{clip} = MVP \cdot P_{local}$

이후 클립 공간의 좌표 $P_{clip}$에 원근 나누기를 적용하여 NDC 좌표를 얻고, 최종적으로 뷰포트 변환을 거쳐 화면에 픽셀로 그려지게 됩니다 (이 과정을 **래스터화**라고 합니다).